/* eslint-disable react-hooks/exhaustive-deps */
/* eslint-disable @typescript-eslint/no-explicit-any */
// contexts/CartContext.tsx

"use client"

import React, {
  createContext,
  useContext,
  useState,
  useEffect,
  useCallback,
  useMemo,
  ReactNode,
} from "react"
import { toast } from "sonner"
import { AddItemToCartRequest, Cart } from "../types/cart"
import { cartService } from "../services/services-cart"
// ‚úÖ AGREGAR: Import del hook de auth
import useAuth from "@/features/login/hooks/useAuth" // Ajusta la ruta seg√∫n tu estructura

// Tipos para el contexto
interface CartContextType {
  // Estado
  cart: Cart | null
  isLoading: boolean
  error: string | null

  // Computed values
  itemCount: number
  total: number
  isEmpty: boolean

  // Acciones
  addItem: (data: AddItemToCartRequest) => Promise<void>
  updateQuantity: (itemId: string, quantity: number) => Promise<void>
  removeItem: (itemId: string) => Promise<void>
  clearCart: () => Promise<void>
  refreshCart: () => Promise<void>
  mergeCarts: () => Promise<void>
  validateForCheckout: () => Promise<any>
  refetch: () => Promise<void>
}

// Crear el contexto
const CartContext = createContext<CartContextType | undefined>(undefined)

// Props del provider
interface CartProviderProps {
  children: ReactNode
}

// Provider del carrito
export function CartProvider({ children }: CartProviderProps) {
  const [cart, setCart] = useState<Cart | null>(null)
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // ‚úÖ AGREGAR: Hook de autenticaci√≥n
  const { user, loading: authLoading } = useAuth()

  // ‚úÖ NUEVA: Funci√≥n para verificar si el error es de autenticaci√≥n
  const isAuthError = useCallback((error: any): boolean => {
    const message = error?.message?.toLowerCase() || ""
    const status = error?.status || error?.response?.status

    return (
      status === 401 ||
      status === 403 ||
      message.includes("forbidden") ||
      message.includes("unauthorized") ||
      message.includes("token") ||
      message.includes("authentication")
    )
  }, [])

  // ‚úÖ MEJORADA: Funci√≥n helper para manejar errores
  const handleError = useCallback(
    (error: any, defaultMessage: string, silent = false) => {
      console.error("‚ùå [CONTEXT] Error:", error)

      // ‚úÖ NUEVO: Si es error de auth, limpiar carrito silenciosamente
      if (isAuthError(error)) {
        console.log(
          "üîê Error de autenticaci√≥n detectado - limpiando carrito local"
        )
        setCart(null)
        setError(null) // No mostrar error de auth al usuario
        return
      }

      // Para otros errores, mostrar normalmente
      const message = error?.message || defaultMessage
      setError(message)

      if (!silent) {
        toast.error(message)
      }
    },
    [isAuthError]
  )

  // ‚úÖ MEJORADA: Cargar carrito inicial con verificaci√≥n de auth
  const fetchCart = useCallback(async () => {
    // ‚úÖ NUEVO: No hacer fetch si no hay usuario autenticado
    if (!user) {
      console.log("üëª No hay usuario autenticado - limpiando carrito local")
      setCart(null)
      setError(null)
      return
    }

    try {
      setIsLoading(true)
      setError(null)
      console.log("üîÑ [CONTEXT] Cargando carrito para usuario:", user.email) // Debug

      const response = await cartService.getCurrentCart()
      console.log("üì¶ [CONTEXT] Respuesta cruda del servicio:", response) // Debug

      let cartData: Cart | null = null

      if (response && typeof response === "object" && "data" in response) {
        cartData = response.data as Cart
      } else {
        cartData = response as Cart
      }

      console.log("üì¶ [CONTEXT] Carrito adaptado:", cartData) // Debug
      console.log(
        "üì¶ [CONTEXT] Items en carrito:",
        cartData?.items?.length || 0
      ) // Debug

      setCart(cartData)
      console.log("‚úÖ [CONTEXT] Estado del carrito actualizado") // Debug
    } catch (error) {
      console.log("‚ùå [CONTEXT] Error cargando carrito:", error) // Debug
      handleError(error, "Error al cargar el carrito")
    } finally {
      setIsLoading(false)
    }
  }, [user, handleError]) // ‚úÖ AGREGAR: user como dependencia

  // ‚úÖ MEJORADA: Agregar item al carrito con verificaci√≥n de auth
  const addItem = useCallback(
    async (data: AddItemToCartRequest) => {
      // ‚úÖ NUEVO: Verificar autenticaci√≥n antes de agregar
      if (!user) {
        toast.error("Debes iniciar sesi√≥n para agregar productos al carrito")
        return
      }

      try {
        setIsLoading(true)
        setError(null)
        console.log("üõí [CONTEXT] Agregando al carrito:", data) // Debug

        const addResponse = await cartService.addItem(data)
        console.log("‚úÖ [CONTEXT] Respuesta de agregar item:", addResponse) // Debug

        // Refrescar el carrito despu√©s de agregar
        console.log("üîÑ [CONTEXT] Refrescando carrito despu√©s de agregar...") // Debug
        await fetchCart()

        console.log(
          "üéØ [CONTEXT] Carrito refrescado, verificando nuevo estado..."
        ) // Debug
        toast.success("Producto agregado al carrito correctamente")
      } catch (error) {
        console.error("‚ùå [CONTEXT] Error agregando al carrito:", error) // Debug
        handleError(error, "Error al agregar producto al carrito")
      } finally {
        setIsLoading(false)
      }
    },
    [user, fetchCart, handleError] // ‚úÖ AGREGAR: user como dependencia
  )

  // ‚úÖ MEJORADA: Actualizar cantidad con verificaci√≥n de auth
  // En tu contexto, reemplaza updateQuantity con esta versi√≥n:
  // Reemplaza tu funci√≥n updateQuantity con esta versi√≥n corregida:

  // Funci√≥n updateQuantity corregida con sincronizaci√≥n autom√°tica:

  const updateQuantity = useCallback(
    async (itemId: string, quantity: number) => {
      if (!user) {
        toast.error("Debes iniciar sesi√≥n para modificar el carrito")
        return
      }

      try {
        setIsLoading(true)
        setError(null)

        // Obtener el productId desde el item
        const currentCart = await cartService.getCurrentCart()
        const cartData = currentCart?.data || currentCart
        const item = cartData?.items?.find((item: any) => item.id === itemId)

        if (!item) {
          toast.error("El producto ya no est√° en tu carrito")
          await fetchCart()
          return
        }

        // Usar productId en lugar de itemId
        console.log(
          "üîó Llamando endpoint con productId:",
          `/cart/items/${item.productId}`
        )
        await cartService.updateItemQuantity(item.productId, { quantity })
        await fetchCart()

        toast.success("Cantidad actualizada correctamente")
      } catch (error) {
        console.log("‚ùå Error en updateQuantity:", error)
        await fetchCart()
        handleError(error, "Error al actualizar la cantidad")
      } finally {
        setIsLoading(false)
      }
    },
    [user, fetchCart, handleError]
  )

  // ‚úÖ MEJORADA: Eliminar item con verificaci√≥n de auth
  const removeItem = useCallback(
    async (itemId: string) => {
      if (!user) {
        toast.error("Debes iniciar sesi√≥n para modificar el carrito")
        return
      }

      try {
        setIsLoading(true)
        setError(null)

        await cartService.removeItem(itemId)
        await fetchCart()

        toast.success("Producto eliminado del carrito correctamente")
      } catch (error) {
        handleError(error, "Error al eliminar el producto")
      } finally {
        setIsLoading(false)
      }
    },
    [user, fetchCart, handleError]
  )

  // ‚úÖ MEJORADA: Vaciar carrito con verificaci√≥n de auth
  const clearCart = useCallback(async () => {
    if (!user) {
      // Si no hay usuario, solo limpiar local
      setCart(null)
      return
    }

    try {
      setIsLoading(true)
      setError(null)

      await cartService.clearCart()
      setCart(null)

      toast.success("Se eliminaron todos los productos del carrito")
    } catch (error) {
      handleError(error, "Error al vaciar el carrito")
    } finally {
      setIsLoading(false)
    }
  }, [user, handleError])

  // ‚úÖ MEJORADA: Refrescar carrito con verificaci√≥n de auth
  const refreshCart = useCallback(async () => {
    if (!user) return

    try {
      setIsLoading(true)
      setError(null)

      const response = await cartService.refreshCart()
      setCart(response.data)

      toast.success("Los precios y stock se han actualizado")
    } catch (error) {
      handleError(error, "Error al actualizar el carrito")
    } finally {
      setIsLoading(false)
    }
  }, [user, handleError])

  // ‚úÖ MEJORADA: Fusionar carritos con verificaci√≥n de auth
  const mergeCarts = useCallback(async () => {
    if (!user) return

    try {
      setIsLoading(true)
      setError(null)

      const response = await cartService.mergeCarts()
      setCart(response.data)

      toast.success("Los carritos se fusionaron correctamente")
    } catch (error) {
      handleError(error, "Error al fusionar los carritos")
    } finally {
      setIsLoading(false)
    }
  }, [user, handleError])

  // ‚úÖ MEJORADA: Validar carrito con verificaci√≥n de auth
  const validateForCheckout = useCallback(async () => {
    if (!user) {
      toast.error("Debes iniciar sesi√≥n para continuar")
      return { success: false, valid: false }
    }

    try {
      setIsLoading(true)
      setError(null)

      const result = await cartService.validateCartForCheckout()

      if (!result.valid && result.errors) {
        toast.error(`Carrito no v√°lido: ${result.errors.join(", ")}`)
      }

      return result
    } catch (error) {
      handleError(error, "Error al validar el carrito")
      return { success: false, valid: false }
    } finally {
      setIsLoading(false)
    }
  }, [user, handleError])

  // ‚úÖ NUEVO: Effect para manejar cambios de autenticaci√≥n
  // ‚úÖ MEJORADO: Effect para manejar cambios de autenticaci√≥n
  useEffect(() => {
    console.log("üîÑ Auth effect - authLoading:", authLoading, "user:", !!user)

    // ‚úÖ CAMBIO: Solo proceder cuando auth haya terminado de cargar
    if (authLoading) {
      console.log("‚è≥ Auth loading...")
      return
    }

    // ‚úÖ CAMBIO: Ser expl√≠cito sobre los estados
    if (user && user.email) {
      // Verificar que realmente tengamos un usuario v√°lido
      console.log("üë§ Usuario autenticado - cargando carrito")
      fetchCart()
    } else {
      console.log("üëª Usuario no autenticado - limpiando carrito")
      setCart(null)
      setError(null)
      setIsLoading(false)
    }
  }, [user?.email, authLoading, fetchCart])

  // ‚úÖ MEJORADO: Computed values con useMemo
  const itemCount = useMemo(() => {
    const count = cart?.items?.length || 0
    console.log(
      "üéØ [CONTEXT] Calculando itemCount:",
      count,
      "desde items:",
      cart?.items
    ) // Debug
    return count
  }, [cart?.items])

  const total = useMemo(() => {
    const totalValue = cart?.summary?.total || cart?.summary?.subtotal || 0
    console.log("üéØ [CONTEXT] Calculando total:", totalValue) // Debug
    return totalValue
  }, [cart?.summary?.total, cart?.summary?.subtotal])

  const isEmpty = useMemo(() => {
    const empty = itemCount === 0
    console.log("üéØ [CONTEXT] Calculando isEmpty:", empty) // Debug
    return empty
  }, [itemCount])

  // Debug effects
  useEffect(() => {
    console.log("üîî [CONTEXT] itemCount cambi√≥ a:", itemCount)
  }, [itemCount])

  useEffect(() => {
    console.log("üîî [CONTEXT] Cart cambi√≥:", cart)
  }, [cart])

  console.log("üéØ [CONTEXT] Valores actuales:", {
    itemCount,
    total,
    isEmpty,
  }) // Debug

  // Valor del contexto
  const contextValue: CartContextType = {
    // Estado
    cart,
    isLoading,
    error,

    // Computed values
    itemCount,
    total,
    isEmpty,

    // Acciones
    addItem,
    updateQuantity,
    removeItem,
    clearCart,
    refreshCart,
    mergeCarts,
    validateForCheckout,
    refetch: fetchCart,
  }

  return (
    <CartContext.Provider value={contextValue}>{children}</CartContext.Provider>
  )
}

// Hook personalizado para usar el contexto
export const useCartContext = (): CartContextType => {
  const context = useContext(CartContext)

  if (context === undefined) {
    throw new Error("useCart debe ser usado dentro de un CartProvider")
  }

  return context
}
